# 7453번 : 합이 0인 네 정수
### 정수로 이루어진 크기가 같은 배열 A, B, C, D가 있을 때, A[a], B[b], C[c], D[d]의 합이 0인 (a, b, c, d) 쌍의 개수를 구하는 프로그램 작성하기
#### 조건
- 배열의 크기 ```N```은 ```1``` 이상 ```4000``` 이하인 자연수
- 배열에 들어있는 정수의 절댓값은 최대 ```2^28```
### 풀이  
문제는 간단하다. 하지만 많은 코딩 테스트의 문제가 그렇듯이 우리들의 발목을 잡는 것은 역시나 ```시간 초과``` 문제였다.  
```N```의 크기가 최대 ```4000```이기 때문에 4개의 배열에 대하여 모든 합의 경우를 따져본다면 시간 복잡도 ```O(N^4)```가 걸리게 된다. 그렇기 때문에 ```완전 탐색```의 방법으로는 이 문제를 해결할 수 없다.   

시간 복잡도를 줄이는 간단한 방법으로는 ```이진 탐색```이 있다.  
그렇다면 ```이진 탐색```을 이용하되, 어떻게 이 문제에 적용해야할까?  
방법은 아래와 같다.  
```
1. 배열 A, B의 모든 합을 담은 새로운 배열 AB를 만든다. 
2. 배열 C, D의 모든 합을 담은 새로운 배열 CD를 만든다. 
3. 이진 탐색을 위해 새로 만든 배열을 정렬한다.
4. 배열 AB를 순차 탐색하며, 합이 0이 되는 target을 계산한다.
5. 위의 target을 기준으로 배열 CD를 이진 탐색 한다.
(단, 배열은 같은 값을 가질 수 있으므로 lower_bound와 upper_bound 개념을 적용한 이진 탐색 2회를 실시한다.)
```
```lower_bound```와 ```upper_bound```는 ```이진 탐색```의 심화 스킬인데, 탐색하고자하는 값이 배열에 여러개 존재할때 그 값의 가장 왼쪽 인덱스와 가장 오른쪽 인덱스를 구하는 방법이다.  
이코테 책에서 학습해봤듯이 2번의 ```이진 탐색```을 수행하며, ```lower_bound```의 ```이진 탐색```은 탐색 값을 찾더라도 ```end```의 값을 줄이고, 반대로 ```upper_bound```의 ```이진 탐색```은 ```start```의 값을 늘린다.  
마지막에 ```upper_bound```와 ```lower_bound```의 차이를 구하면 우리가 찾고자하는 값이 배열에 몇 개 존재하는지 찾을 수 있다!   

<br>
<br>
(+ 한편으로 문제를 풀면서 어려웠던 또다른 부분으로는 배열 A, B 와 C, D 대해 각각 합을 더해 2개의 새로운 배열을 생성한다는 아이디어를 생각해내는 것이었다..🥲)

