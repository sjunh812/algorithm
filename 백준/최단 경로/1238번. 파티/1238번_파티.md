# 1238번 : 파티
### N개의 숫자로 구분된 각각의 마을에 학생들이 살고 있다. 이때 N명의 학생들이 X 마을에 모여 파티를 벌이기로 할 때, N명의 학생들 중 오고 가는데 가장 많은 시간을 소비하는 학생의 소요시간을 구하는 프로그램 작성하기
#### 조건
- 마을 및 학생의 수 ```N```(1 ≤ N ≤ 1,000), 단방향 도로의 개수 ```M```(1 ≤ M ≤ 10,000), 파티할 마을 ```X```(1 ≤ X ≤ N)가 주어짐.
- 각각의 학생들은 파티에 참석하기 위해 걸어가서 다시 그들의 마을로 돌아와야 하며, 최단 시간으로 오고 가야함.
- 시작점과 끝점이 같은 도로는 없으며, 한 마을 ```A```에서 다른 마을 ```B```로 가는 도로의 개수는 최대 ```1개```
- 모든 학생들은 집에서 마을 ```X```에 갈수 있고, ```X```에서 집으로 돌아올 수 있는 데이터만 입력으로 주어짐.
- 시간 제한 ```1초```
### 풀이
이 문제는 **최단 경로** 알고리즘을 통해 해결할 수 있는 문제이다.
**최단 경로** 알고리즘으로 ```BFS(너비 우선 탐색)```, ```다익스트라```, ```플로이드-워셜``` 알고리즘을 주로 사용한다.  
```BFS```의 경우 간선의 비용이 모두 같을 때, 한 점에 대한 모든 지점의 최단 거리를 구할 때 사용한다. 하지만 이 문제의 간선의 비용은 각기 다르기 때문에 ```BFS```외 다른 방법을 사용해야한다.  
다음으로 구현이 간단한 ```플로이드-워셜```알고리즘을 살펴보자. ```플로이드-워셜``` 알고리즘의 경우 시간 복잡도 ```O(N^3)```을 가진다. 그러므로 ```N```이 최대 ```1000```임을 감안하면 시간 초과가 날 것을 예상할 수 있다.  
결국 이 문제를 해결할기 위해 ```다익스트라``` 알고리즘을 사용해야 한다.

일반적인 생각의 흐름으로 ```다익스트라```알고리즘을 이용해 구현하면 아래와 같은 순서로 구현할 것이다.
```
1. 모든 학생의 시작점에서 다익스트라 알고리즘을 각각 수행 → N * ElogN
2. X를 시작점으로 다익스트라 알고리즘을 수행 → ElogN
```
위의 구현방식으로 대략 ```(N + 1) * ElogN```의 시간 복잡도가 소요되므로 시간 초과에 걸릴 수 있다.  
그러므로 약간의 생각의 전환이 필요한데, **간선의 방향을 거꾸로하여** 도착점을 시작점으로 하는 방법을 사용해야한다.  
이 방법을 통해 구현하면 아래와 같은 순서로 진행된다.
```
1. 두 개의 그래프를 입력받는다.(정방향 간선, 역방향 간선)
2. 역방향 간선을 입력받은 그래프를 사용해서 X를 시작점으로 다익스트라 알고리즘 수행 → ElogN
3. 정방향 간선을 입력받은 그래프를 사용해서 X를 시작점으로 다익스트라 알고리즘 수행 → ElogN
``` 
``2번``에서 나온 최단 거리 테이블을 이용하면 각각의 학생의 마을로부터 ```X``` 마을까지의 최단 거리를 구할 수 있다.  
위의 구현방식은 ```2 * ElogN``` 즉, ```ElogN```의 시간 복잡도를 가지므로 시간 초과 없이 문제를 해결할 수 있다.  


앞으로 이런 유형의 문제를 보면, 간선의 방향을 뒤집어 최단 경로를 계산하는 방법도 생각해 봐야 한다!