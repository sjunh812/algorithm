# 5430번 : AC
### 배열의 초기값과 수행할 함수가 주어졌을 때, 최종 결과를 구하는 프로그램 작성하기
#### 조건
- 첫째 줄에는 테스트 케이스의 개수 ```T```가 주어짐.(```T```는 최대 100)
- 각 테스트 케이스 첫째 줄에는 수행할 함수 ```p```가 주어짐(1 <= p <= 100000)
- 다음 줄에는 배열의 길이 ```n```이 주어짐(0 <= n <= 100000)
- 다음 줄에는 ```[x1,...,xn]```과 같은 형태로 배열에 들어있는 정수가 주어짐.(1 <= x <= 100)
- 전체 테스트 케이스에 주어지는 ```p```의 길이의 합과 ```n```의 합은 **70만**을 넘지 않는다.
- 함수에는 두 가지 종류가 있는데 ```R```은 배열의 순서를 뒤집는 함수, ```D```는 배열의 첫 번째 수를 버리는 함수임.
### 풀이
이 문제의 조건은 매우 단순하다.  
함수의 종류가 ```순서 뒤집기```, ```앞의 수 버리기``` 단 2가지밖에 없기 때문이다.  
뜻밖에 부분에서 발목을 잡게되는데 그것은 바로 주어진 입력 값들의 ```범위```이다.  

테스트 케이스의 개수는 최대 ```100```, 배열의 길이는 최대 ```10만```, 또 함수의 길이 역시 ```10만```이다.  
테스트 케이스를 최대 ```100```번 시행할 동안, 연산을 위한 리스트를 만드는데 배열의 길이만큼 최대 ```10만```, 함수들을 순회하는데 함수의 길이만큼 최대 ```10만```, 마지막으로 리스트 결과를 출력하기 위한 최대 ```10만```의 연산 횟수가 소요된다.  
다행히도 문제의 조건에 **"전체 테스트 케이스에 주어지는 ```p```의 길이의 합과 ```n```의 합은 ```70만```을 넘지 않는다"** 라고 주어졌기 때문에 연산 횟수가 ```1000만``` 아래로 ```1초```안에 구현할 수 있을 것으로 예상된다.  

그런데 위의 연산 횟수를 고려하면서 빼먹은 부분이 있었는데 바로 함수의 세부 연산이다.  

함수에는 크게 ```뒤집기(reverse)```와 ```버리기(remove)``` 두 가지 종류가 있다. 일반적으로 **Java**에서 리스트를 작성할 때, ```ArrayList```를 제일 많이 이용한다. 하지만 ```ArrayList```의 경우 **삭제** 및 **뒤집기**에 **O(n)** 의 시간 복잡도를 가진다. 이에 따라 추가적으로 함수의 세부 연산에 대한 횟수가 곱해지므로 ```시간 초과```라는 장벽에 부딪히게 된다.  

우리가 생각할 수 있는 ```ArrayList```를 대체 할 방법으로 삭제에 효율적인 ```Queue```가 제일 먼저 떠올릴 수 있다. 하지만 큐의 경우 제일 앞의 원소 삭제에만 **O(1)** 의 시간복잡도를 가지므로, ```뒤집기 + 삭제```에 대해 효율적이지 못하다. 그렇다면 앞, 뒤 삭제에 효율적인 컬렉션은 무엇일까?  

바로 ```Deque```라는 컬렉션이 있는데 ```Deque```는 제일 앞과 뒤에서 원소를 추가, 삭제에 용이한 **양방향 큐** 이다. ```Deque```를 사용한다면 뒤집기 이후의 버리기에도 효율적으로 수행할 수 있다!!  

정리하면, 문제의 해법은 아래와 같다.
```
0. 리스트에 양방향 큐인 Deque를 이용한다.
1. 뒤집기의 경우 boolean 매개변수를 통해 방향에 대한 정보를 저장한다.
2. 버리기의 경우 위에서 저장한 매개변수를 통해 정방향은 앞의 원소, 역방향은 뒤의 원소를 삭제한다.
3. 모든 함수 연산이 종료되고, 방향 정보에 따라 출력 해준다.
  (Deque의 경우, 순회에 보통의 컬렉션과 동일하게 Iterator를 이용한다. 그래서 iterator() 메소드를 이용해
  Iterator 객체를 생성해주면 되는데, 한 가지 추가된 점이 descendingIterator()를 이용하면 뒤에서부터
  순회하는 효과를 가질 수 있다!)
```

**추가적으로 고려해야하는 점으로 입출력에 ```Scanner```와 ```System.out.println()``` 을 사용하지 않고,  
```BufferedReader```와 ```BufferedWriter```를 사용하자.**
