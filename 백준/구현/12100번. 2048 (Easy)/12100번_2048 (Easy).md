# 12100번 : 2048 (Easy)
### 보드의 크기와 보드판의 블록 상태가 주어졌을 때, 최대 5번 이동해서 만들 수 있는 가장 큰 블록의 값을 구하는 프로그램을 작성하기
#### 조건
- 보드의 크기 ```N```이 주어짐.(1 <= N <= 20)
- 블록에서 ```0```은 ```빈칸```, 이외의 값들은 모두 블록을 나타냄.  
  (블록에 쓰여 있는 수는 2 보다 크거나 같고, 1024 보다 작거나 같은 2의 제곱꼴)
- 블록은 적어도 하나 주어짐.
- 게임에서 한 번의 이동은 보드 위에 있는 전체 블록을 ```상하좌우``` 4 방향 중 하나로 이동시키는 것
- 이동 후 같은 값을 갖는 블록이 충돌하면 두 블록은 하나로 합쳐짐.  
  (단, 이미 합쳐진 블록은 또 다른 블록과 다시 합쳐질 수 없음.) 
### 풀이
문제에서 주어진 보드의 크기는 최대가 ```20```이므로 ```완전 탐색```을 이용해서 해결할 수 있다.  
다만, 문제에서 주어진 조건에 맞게 확인하면서 탐색해야하므로 ```시뮬레이션``` 문제라고도 할 수 있다.

효율적인 ```완전 탐색```을 위해 ```백트래킹```을 이용했다.  
아래에서 ```백트래킹```시 고려해야할 조건을 정리해보았다.
```
1. 이동 방향은 상하좌우 총 4가지이므로 탐색 시, 모든 방향을 고려해야한다.
2. 이미 합쳐진 블록은 다시 합쳐질 수 없으므로, 이동시킬 방향 제일 끝부터 역방향으로 탐색을 한다.
3. 현재 기준 블록과 다음 블록을 비교하며, 다음 블록의 값이 0이면 다음 블록을 이동시킨다.
 - 만약 현재 블록과 다음 블록의 값이 같다면 합치고, 그렇지 않다면 현재 블록의 값을 유지한다.
 - 비교한 두 블록이 같다면, 현재 기준 블록을 비교한 다음 블록 다음으로 바꿔준다.
 - 비교한 두 블록이 다르다면, 현재 기준 블록을 비교한 다음 블록으로 바꿔준다.
```

즉, ```시뮬레이션``` 문제이기 때문에 **블록이 합쳐지는 조건**에 유의하면서 코드를 작성한다면, 문제를 해결할 수 있다!  
다만, 블록이 ```빈칸```인 예외가 있기 때문에 이 부분을 코드를 옮기는게 비교적 까다로웠던 것 같다.