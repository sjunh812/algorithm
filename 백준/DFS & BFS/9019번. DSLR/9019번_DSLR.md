# 9019번 : DSLR
### 주어진 서로 다른 정수 A와 B(A != B)에 대하여 A를 B로 바꾸는 최소한의 명령어를 생성하는 프로그램 작성하기
#### 조건
- 네 개의 명령어 ```D```, ```S```, ```L```, ```R```이 있을 때, 다음과 같이 0 이상 10000 미만의 십진수 ```n```을 변환함.
  - ```D``` : ```n```을 두 배로 바꾼다. 결과 값이 ```9999``` 보다 큰 경우에는 ```10000``` 으로 나눈 **나머지**를 취한다.
  - ```S``` : ```n```에서 ```1```을 뺀 결과를 저장한다. ```n```이 ```0``` 이라면 ```9999```를 대신 저장한다.
  - ```L``` : ```n```의 각 자릿수를 **왼편**으로 회전한다.
  - ```R``` : ```n```의 각 자릿수를 **오른편**으로 회전한다.
- 테스트 케이스의 개수 ```T```가 입력의 첫 줄에 주어짐.
- 가능한 명령어의 나열이 여러가지면, 아무거나 출력함.
### 풀이  
**최소한의 명령어를 생성** 해야하기 때문에 ```너비 우선 탐색(BFS)```를 이용해야한다는 사실을 알 수 있다.  
```깊이 우선 탐색(DFS)```의 경우 탐색을 완료한 명령어의 나열이 최소임을 보장할 수 없기 때문이다.  
따라서 가장 가까운 노드부터 우선 탐색하는 ```BFS```를 이용해 문제를 해결할 수 있다.  

```BFS```의 경우 **큐**를 사용하여 구현하는데, 이 문제에선 한 개의 큐를 추가로 생성해서 구현했다.  
먼저 명령어의 따른 변환 값 ```n```을 저장할 큐와 명령어의 나열을 저장할 큐를 추가했다. 두 가지 큐를 이용하지 않으려면, ```n``` 값과 명령어의 나열을 담은 클래스를 따로 생성하여 구현해도 된다.  

```D```, ```S```, ```L```, ```R```에 대한 간선의 비용이 동일함으로 일반적인 ```BFS``` 구현방식과 동일하게 구현하면 문제를 해결할 수 있다!
