# 2206번 : 벽 부수고 이동하기
### 맵이 주어졌을 때, 최단 경로를 구해 내는 프로그램 작성하기
#### 조건
- ```N x M```의 행렬로 표현되는 맵(1 <= N, M <= 1000)
- 맵에서 ```0```은 이동할 수 있는 곳, ```1```은 이동할 수 없는 벽을 나타냄.
- ```(1, 1)```에서 ```(N, M)```의 위치까지 이동하고자 함.
- 최단 경로를 계산할 때, 시작하는 칸과 끝나는 칸도 포함해서 셈.
- 만약 이동하는 도중에 ```1개```의 벽을 부수고 이동하는 것이 좀 더 경로가 짧아진다면, 벽을 ```1개``` 까지 부수고 이동하여도 됨.
- 한 칸에서 이동할 수 있는 범위는 ```상, 하, 좌, 우```
### 풀이  
간선의 비용이 ```1```일 때, **최단 거리**를 구하는 문제는 전형적인 ```너비 우선 탐색(BFS)``` 문제 유형이다.  
이 문제가 그런 유형인데, 특이한 부분이 벽을 ```1개```까지 부수고 이동할 수 있는 경우도 존재한다는 것이다.  
처음에는 단순히 벽을 부수지 않고 계산할 때와 임의의 벽 중에 1개의 벽을 부수고 계산할 때 중에 최단 거리가 제일 짧을 경우를 답으로 하는 코드를 작성했다.  
하지만 이는 **시간 초과**로 이어졌다. 어쩌면 당연한 결과이었던 것이 임의의 벽 1개 고르는 시간 복잡도를 ```O(N * M)```라고 하면, 이 때의 ```BFS```를 구하는 시간 복잡도는 ```O((N * M)^2)```가 된다.   
```N```과 ```M```의 범위가 최대 ```1000```인 것을 감안하면 1억을 넘고도 훨씬 큰 수 이기 때문에 **시간 초과**에 걸릴 수 밖에 없다..  

이 문제를 해결하기 위해서는 그동안 ```BFS```에 이용했던 방문 처리 방식을 살짝 다르게 구현하면 된다.  
방문 처리에 사용할 배열을 ```visited```라고 정의 하자.  
보통 이런 문제에서 우리는 ```visited```를 2차원 배열로 정의한다. 하지만 이 문제에서는 살짝 다르게 **3차원 배열**로 정의해보자. 그 이유는 아래와 같다.    
```visited[행][열][벽을 부순적 있는지 여부]```를 표현하기 위함이다!  
만약 3차원 배열의 계산이 복잡하다고 느껴진다면 2차원 배열 ```visited```를 벽을 부수지 않고 계산할 때와 한개의 벽을 부수고 계산할 때로 나눠 2개의 배열로 정의해서 사용하면 된다.

그런데 여기서 의문점이 생긴다.  
벽을 부수지 않고 계산할 때의 방문 처리는 가능한 것 같은데, 한개의 벽을 부수고 계산할 때의 방문처리는 왜 한 곳에서 이뤄질까? 분명히 여러 개의 벽 중 한 개의 벽을 선택할 때마다 다른 방문 노드를 가질텐데 말이다.  

이는 우리가 **최단 거리**를 계산하기 때문에 가능한 방법으로 어처피 여러 개의 벽 중에 1개를 고르는 수많은 경우 중 우리가 필요한 결과는 **최단 거리**이기 때문에 하나의 방문 노드에서 처리해도 무방하다.

<br>
<br>
<br>
생각보다 간단한줄 알았지만 까다롭고, 어려웠던 문제였던 것 같다...😔

