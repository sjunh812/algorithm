# 11501번 : 주식
### 날 별로 주식의 가격을 입력받을 때, 최대 이익이 얼마나 되는지 계산하는 프로그램 작성하기
#### 조건
- 날마다 아래 3가지 중 한 행동을 함.
  1. 주식 하나를 산다.
  2. 원하는 만큼 가지고 있는 주식을 판다.
  3. 아무것도 안한다.
- 예를 들어 날 수가 ```3일```이고 날 별로 주가가 ```10```, ```7```, ```6```일 때, 주가는 계속 감소하므로 최대 이익이 ```0```이 됨. 그러나 만약 날 별로 주가가 ```3```, ```5```, ```9```일 때는 처음 두 날에 주식을 하나씩 사고, 마지막날 다 팔아 버리면 이익이 ```10```이 됨.
- 날의 수를 나타내는 자연수 ```N```(2 ≤ N ≤ 1,000,000)이 주어지며, 날 별 주가는 ```10,000``` 이하
- 각 테스트케이스 별로 최대 이익을 나타내는 정수 하나를 출력하는데, 답은 ```부호있는 64bit 정수형```으로 표현 가능함.
### 풀이
이 문제는 ```그리디``` 알고리즘을 이용해서 풀 수 있는 문제이다.  

처음 이 문제를 ```우선순위 큐(Priority Queue)```를 이용해서 해결했다.  
주가가 큰 순서대로 주가와 인덱스의 정보를 담아 ```우선순위 큐```에 삽입한 뒤, 큐에 있는 주식의 대한 정보를 하나씩 빼면서 최대 이익을 계산하였다.  
만약 ```우선순위 큐```에서 빼낸 주식의 인덱스(순서)가 ```5```라고 해보면, **0부터 4번째 날**까지의 주가를 모두 사고 마지막 **5번째** 날에 다 팔아 최대 이익에 더해주었다. 그런 뒤에 다음 탐색 인덱스로 위에서 빼낸 주식의 다음 인덱스로 지정한다.  
위의 로직을 탐색 인덱스가 ```n - 1```보다 크거나 같을 때까지 반복하면 최대 이익을 구할 수 있다.  

위의 방식으로도 정답 판정은 받을 수는 있다. 하지만 ```우선순위 큐```에 삽입하는 시간 복잡도 ```O(NlogN)```과 ```우선순위 큐```에 삽입된 값을 빼내는 로직에서 최대 이익을 구하는 시간 복잡도 ```O(N)```이 소요되므로 전체 시간 복잡도 ```O(NlogN + N)```이 소요된다.   
```N```이 최대 ```1000000```임을 감안하면 위의 방식은 효율성이 떨어진다고 할 수 있다.

문제에 대해 좀 더 깊게 생각 해보자.  
만약 주어진 주가를 차례대로 순회한다고 할 때, 주어진 주가 중 최댓값을 찾고 그 날 까지의 최대이익을 구하는 행위를 순회 인덱스를 갱신하면서 반복하길 원한다.
하지만 위 로직에는 한 가지 문제가 있는데, 순회하면서 갱신되는 최댓값이 주어진 모든 주가 중 최댓값이라는 보장이 없다는 것이다.  
즉, 차례대로 순회하면서 최댓값을 찾아도 결국에는 뒤에 나오는 더 큰 최댓값에 따라 또 최대이익이 결정된다.  
따라서 뒤에서부터 차례대로 순회하면서 값이 커지는 시점에는 뒤의 최댓값이 갱신해주고, 값이 작아지는 시점에는 ```(갱신된 최댓값) - array[위치]```를 최대 이익에 합해주면 된다.

위의 방식을 이용하면 반복문 한번의 시간 복잡도 ```O(N)```으로 간단하게 해결할 수 있다!  