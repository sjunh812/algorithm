# 1744번 : 수 묶기
### 수열이 주어졌을 때, 수열의 각 수를 적절히 묶어 수열의 합이 최대가 되게 하기
#### 조건
- 길이가 N인 수열이 주어졌을 때, 그 수열의 합을 구한다.
- 단, 수열 내 두 수를 묶으려고 하는데, 묶은 수는 서로 곱한다.
- 위치에 상관없이 묶을 수 있다. 단, 같은 위치에 있는 수는 묶지 못한다.
- 수열의 모든 수는 단 한번만 묶거나, 묶지 않는다. 
### 풀이
**합이 최대가 되게 하기**라는 말을 통해 ```그리디 알고리즘```을 이용하면 해결할 수 있다는  
사실을 알 수 있다. 두 수를 묶으면 곱 연산을 하기 때문에, 곱 연산을 최대한 많이 이용해야 합을 크게  
할 수 있다. 하지만 이 문제가 까다로웠던 이유는 ```음수```와 ```0```의 존재와 더하기 연산이 유리한 경우를  
판단해줘야 했기 때문인데, 이 부분을 잘 따져가며 수를 묶어줘야 한다.

풀이과정은 간단히 아래와 같은 순서로 진행된다.
```
1. 수열의 정렬 
  (정렬 기준 : 
    1) 내림차순 정렬
    2) 비교하는 두 수가 0보다 작거나 같을 경우 절댓값으로 내림차순 정렬
    ex) [4, -2, 0, 1, 2, -5] → [4, 2, 1, -5, -2, 0]
  )
2. 정렬된 수열을 차례대로 확인
  (조건 :
    곱하기(묶음) -  두 수가 1보다 큰 양수 or 두 수가 음수 or 음수 + 0의 조합
    더하기(묶음x) - 위 조건 외 나머지
  )
```

위의 알고리즘의 핵심은 **정렬**이라고 생각한다.  
비교할 두 수가 모두 0보다 작거나 같은 수일 때, 절댓값 내림차순의 조건을 부여함으로서,  
음수 간의 곱의 결과를 최대로 만들 수 있었다. 추가적으로 하나의 음수와 0이 남을 조건을  
제일 낮은 우선순위로 두어 묶을 수 있는 조건을 만들어 주었다.

이 문제를 정확하고, 효율적으로 잘 해결했는지는 모르겠다..ㅠㅠ  
문제에 대한 이해는 빨랐지만, 다양한 경우의 수로 고전했기 때문에  
여러 조건을 좀 더 신중하게 많이 따져가며 코드를 작성 해야겠다는 생각이 들었다.. 