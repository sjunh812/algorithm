# 1781번 : 컵라면
### 데드라인이 정해져 있는 N개의 문제가 주어질 때, 문제를 풀어 받을 수 최대 컵라면 수를 출력하는 프로그램 작성하기
#### 조건
- 문제의 개수 ```N```(1 ≤ N ≤ 200,000)이 주어짐.
- 문제를 푸는데는 단위 시간 ```1```이 걸리며, 각 문제의 데드라인은 ```N```이하의 자연수
- 각 문제를 풀 때 받을 수 있는 컵라면 수와 최대로 받을 수 있는 컵라면 수는 모두 ```2^31```보다 작거나 같은 자연수
### 풀이
이 문제는 ```우선 순위(Priority Queue)```를 이용해서 풀 수 있는 ```그리디``` 알고리즘 유형의 문제이다.  

한 가지 예시를 통해 문제를 살펴보자.  
아래와 같이 문제의 데드라인과 컵라면 수가 주어졌다.
```
문제번호  1    2    3    4    5    6    7    8    9
데드라인  1    1    2    2    3    4    4    4    5  
컵라면수  14   7   10    5    8   18   12    6    5
```
먼저 주어진 문제의 정보(데드라인, 컵라면 수)를 데드라인 오름차순으로 정렬한다. 이때 만약 데드라인이 같은 경우에는 컵라면 수가 큰 문제를 우선 정렬한다. (편의상 위의 예시는 이미 정렬된 상태로 주어졌다.)   

이제 문제의 정보를 담은 배열을 순차적으로 순회해보자.  
먼저 데드라인 1이고 컵라면 수 14인 문제를 풀 수 있다. 이후 들어오는 데드라인 1, 컵라면 수 7인 문제는 무시된다.  
그렇기 때문에 현재까지 문제를 푸는데 소요된 시간은 ```1```이다. 다음 문제는 데드라인 2, 컵라면수 10인 문제이므로 풀 수 있다.   
이 다음 들어온 데드라인 2, 컵라면수 5인 문제를 보자. 여태까지 **소요된 ```2```의 시간 동안 컵라면 수 ```5```보다 작은 경우가 있다면 이 문제로 대신 풀어야 ```그리디``` 알고리즘에 맞게 최대 컵라면 수를 보장하며 문제를 풀 수 있다.**   
소요된 시간동안 푼 문제 중  **가장 작은 컵라면 수**를 알 수 있어야하므로, 우리는 문제를 풀때마다 컵라면 수를 오름차순 ```우선순위 큐```에 집어넣어서 계산하면 된다.   

이런 규칙에 따라 순회를 하면 최종적으로 ```우선순위 큐```에 담긴 컵라면 수의 합이 우리가 구하고자하는 최대 컵라면 수이다!
