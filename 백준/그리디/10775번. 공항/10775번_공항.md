# 10775번 : 공항
### 가장 많은 비행기를 공항에 도킹시킬 때, 최대 몇 대 도킹시킬 수 있는지 구하기.
#### 조건
- 공항에는 ```G(1<= G <= 10^5)```개의 게이트가 있으며, 각각은 1에서 G까지의 번호를 가지고 있다.
- 공항에는 ```P(1<= P <= 10^5)```개의 비행기가 순서대로 도착할 예정이며, 각 비행기는 ```1부터 g 번째 게이트 중 하나```에 영구적으로 도킹한다.
- 비행기가 어느 게이트에도 도킹할 수 없다면 공항이 폐쇠되고, 이후 어떤 비행기도 도착할 수 없다.
- **시간 제한 1초**(추가 시간 없음)
### 풀이
이 문제는 ```그리디 알고리즘```을 이용하면 문제 해결 방법에 대해서는 쉽게 접근할 수 있다.
각 비행기마다 도킹이 가능한 게이트의 범위(최대 g)를 가지며, 모든 게이트의 범위가 **1부터 시작한다.**  
즉, 게이트의 번호가 클수록 도킹될 확률이 작은 것인데 선택되면 최대한 많은 비행기를 도킹시킬 수 있다는 사실과도 연결된다!  

하지만 문제를 풀면서 발목잡은 것 조건은 1초라는 시간 제한이었다.
일반적으로 10억의 연산 횟수가 넘어가면 시간이 1초 가량 소요되므로 주어진 G와 P의 범위로 보아  
**O(n^2)** 의 시간복잡도를 피하도록 코드를 짜야한다는 사실을 알 수 있다.
위의 문제해결 방법에 따르면 먼저 비행기의 개수(P)만큼 for문을 돌아야한다.  
그 안에서 각 비행기의 도킹 가능한 범위 중에서 가장 큰 번호의 게이트를 선택해야 하는데,  
이를 표현하면 g만큼 탐색이 필요하다.(이중 for문)  
하지만, g가 최대일 때는 G만큼 수를 가질 수 있기 때문에 O(n^2)의 시간복잡도를 가질 수 있다.

이를 피하기 위한 해법은 아래와 같다.
```
1. 게이트마다의 탐색 여부를 담은 int형 배열을 만든다.(0으로 초기화)
2. 비행기별 도킹 가능한 게이트 범위를 탐색(탐색 간격 = 1)하는데, 0을 만나면 탐색을 종료한다.
   → 탐색마다 해당되는 게이트의 탐색여부를 1 증가시켜준다.(후위 연산)
   → 탐색 간격을 해당되는 게이트의 탐색여부 값만큼 할당한다.
3. 비행기 별 도킹 가능한 게이트 범위를 탐색하는 중에 0을 한번도 만나지 못한다면 공항을 폐쇠한다.   
```
탐색마다 탐색여부를 참, 거짓 값으로 저장하는게 아닌 **탐색횟수**로 저장하므로서,  
불필요한 탐색을 줄이는 효과를 가져올 수 있다.  
예를 들어 g가 7인 비행기가 3개가 존재할 때, 7번 게이트의 탐색횟수는 2회(후위 연산)이다.(제일 번호가 큰 게이트 우선적으로 탐색)  
처음 탐색 때는 7번 게이트 선택, 2 번재 탐색 때는 6번 게이트 선택, 마지막으로 3 번째 탐색 때는 5번 게이트가 
선택될 것이므로 **후위 연산된 탐색횟수**만큼 차감해서 탐색범위를 지정하면 좀 더 효율적으로 탐색할 수 있다!
