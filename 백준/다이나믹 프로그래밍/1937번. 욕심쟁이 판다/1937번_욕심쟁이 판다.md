# 1937번 : 욕심쟁이 판다
### n × n 크기의 대나무 숲이 주어져 있을 때, 판다가 이동할 수 있는 칸의 수의 최댓값을 출력하는 프로그램 작성하기
### 조건
- 대나무 숲의 크기 `n`이 주어짐.(1 ≤ n ≤ 500)
- 대나무의 양은 1,000,000보다 작거나 같은 자연수
- 욕심쟁이 판다는 어떤 지역에서 대나무를 먹기 시작하고, 그 곳의 대나무를 다 먹어 치우면 **상, 하, 좌, 우** 중 한 곳으로 이동을 함.
- 판다는 매우 욕심이 많아서 대나무를 먹고 자리를 옮기면 그 옮긴 지역에 그 전 지역보다 대나무가 많이 있어야 함.
### 풀이
격자 형태의 대나무 숲에서 조건에 맞게 이동할 수 있는 칸의 최댓값을 구하는 문제이므로,  
`DFS(깊이 우선 탐색)`과 `BFS(너비 우선 탐색)`을 이용한 풀이방법을 떠올릴 수 있다.  
또한 임의의 지점에 대해 탐색을 수행하면서, 해당 지점에서 이동할 수 있는 최댓값을 **DP** 배열에 저장하는  
**메모이제이션** 즉, `다이나믹 프로그래밍`을 이용할 수 있다.  

예를 들어 [2, 3] 지점에서의 이동할 수 있는 최댓값을 구하자고 가정하자.   
`BFS`는 탐색하는 지점의 주변부터 차례대로 탐색하는 **너비 우선 탐색**이므로, **DP** 값을 갱신하기에 알맞지 않다.  
재귀적으로 [2, 3] 지점에서 이동할 수 있는 최장 거리까지 간 이후에 역으로 돌아오면서 **DP** 값을 저장해야 한다.  
즉, `DFS`와 `다이나믹 프로그래밍`을 이용하면 문제를 해결할 수 있다.  

추가로 각 지점별로 `DFS`를 수행하여 **DP**의 최댓값을 갱신하되,  
만약 탐색하는 지점에 이미 저장된 **DP** 값이 있다면, 더이상 탐색을 진행하지 않아도 된다.  
**왜냐하면 임의의 지점에 대해 저장된 DP 값은 해당 지점에서 이동할 수 있는 최댓값을 보장하기 때문이다.**  