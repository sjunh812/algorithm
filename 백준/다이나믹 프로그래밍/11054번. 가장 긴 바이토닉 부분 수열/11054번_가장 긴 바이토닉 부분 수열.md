# 11054번 : 가장 긴 바이토닉 부분 수열
### 수열 A가 주어졌을 때, 그 수열의 부분 수열 중 바이토닉 수열이면서 가장 긴 수열의 길이를 구하는 프로그램을 작성하기
### 조건
- 수열 `S`가 어떤 수 `Sk`를 기준으로 S1 < S2 < ... Sk-1 < Sk > Sk+1 > ... SN-1 > SN을 만족한다면, 그 수열을 바이토닉 수열이라고 함.
- 예를 들어, `{10, 20, 30, 25, 20}`과 `{10, 20, 30, 40}`, `{50, 40, 25, 10}` 은 바이토닉 수열이며,
 `{1, 2, 3, 2, 1, 2, 3, 2, 1}`과 `{10, 20, 30, 40, 20, 30}` 은 바이토닉 수열이 아님.
- 수열 `A`의 크기 `N`이 주어짐. (1 ≤ N ≤ 1,000)
- 수열 `A`를 이루고 있는 `Ai`가 주어짐. (1 ≤ Ai ≤ 1,000)
### 풀이
이 문제는 [11053번. 가장 긴 증가하는 부분](https://github.com/sjunh812/algorithm/blob/master/%EB%B0%B1%EC%A4%80/%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/11053%EB%B2%88.%20%EA%B0%80%EC%9E%A5%20%EA%B8%B4%20%EC%A6%9D%EA%B0%80%ED%95%98%EB%8A%94%20%EB%B6%80%EB%B6%84%20%EC%88%98%EC%97%B4/Main.java) 수열의 연장 문제이다.  
즉, `다이나믹 프로그래밍`을 이용하면 문제를 해결할 수 있다.   

바이토닉 수열의 정의를 살펴보면, **증가하는 수열**, **감소하는 수열** 또는 **증가하다가 감소하는 수열**일 때 바이토닉 수열이라고 할 수 있다.  
그러므로 2개의 `dp` 배열을 선언하여 해결할 수 있으며, 방법은 아래와 같다.
```
dp1, dp2의 범위 : 0 이상 n + 1 이하

모든 j(0 <= j < i)에 대하여
dp1[i] = max(dp[i], dp[j] + 1) if array[i] > array[j]

모든 j(i < j <= n)에 대하여
dp2[i] = max(dp[i], dp[j] + 1) if array[i] > array[j]

모든 j(i < j <= n)에 대하여
바이토닉 부분 수열의 개수 = max(dp[i], dp1[i] + dp2[j]) if a[i] != a[j]
```
**추가로 바이토닉 부분 수열의 개수를 구할 때, 정순으로 증가하는 범위의 끝값과 역순으로 증가하는 범위의 끝값이 서로 같은 경우는 제외시켜줘야 한다.**    
예를 들어 `{1, 2, 3, 3, 2, 1}` 은 바이토닉 수열이 아니므로, 이를 유의해서 정답을 구해야한다!
