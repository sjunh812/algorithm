# 11054번 : 가장 긴 바이토닉 부분 수열
### 수열 A가 주어졌을 때, 그 수열의 부분 수열 중 바이토닉 수열이면서 가장 긴 수열의 길이를 구하는 프로그램을 작성하기
### 조건
- 수열 `S`가 어떤 수 `Sk`를 기준으로 S1 < S2 < ... Sk-1 < Sk > Sk+1 > ... SN-1 > SN을 만족한다면, 그 수열을 바이토닉 수열이라고 함.
- 예를 들어, `{10, 20, 30, 25, 20}`과 `{10, 20, 30, 40}`, `{50, 40, 25, 10}` 은 바이토닉 수열이며,
 `{1, 2, 3, 2, 1, 2, 3, 2, 1}`과 `{10, 20, 30, 40, 20, 30}` 은 바이토닉 수열이 아님.
- 수열 `A`의 크기 `N`이 주어짐. (1 ≤ N ≤ 1,000)
- 수열 `A`를 이루고 있는 `Ai`가 주어짐. (1 ≤ Ai ≤ 1,000)
### 풀이
이 문제는 백준 11053번. 가장 긴 증가하는 부분 수열의 연장 문제이다.  
즉, `다이나믹 프로그래밍`을 이용하면 문제를 해결할 수 있다.   

바이토닉 수열의 정의를 살펴보면, **증가하는 수열**, **감소하는 수열** 또는 **증가하다가 감소하는 수열**일 때 바이토닉 수열이라고 할 수 있다.  
그러므로 2개의 `dp` 배열을 선언하여 해결할 수 있으며, 방법은 아래와 같다.
```
dp1, dp2의 범위 : 0 이상 n + 1 이하

모든 j(0 <= j < i)에 대하여
dp1[i] = max(dp[i], dp[j] + 1) if array[i] > array[j]

모든 j(i < j <= n)에 대하여
dp2[i] = max(dp[i], dp[j] + 1) if array[i] > array[j]

모든 j(i < j <= n)에 대하여
바이토닉 부분 수열의 개수 = max(dp[i], dp1[i] + dp2[j]) if a[i] != a[j]
```
**추가로 바이토닉 부분 수열의 개수를 구할 때, 정순으로 증가하는 범위의 끝값과 역순으로 증가하는 범위의 끝값이 서로 같은 경우는 제외시켜줘야 한다.**    
예를 들어 `{1, 2, 3, 3, 2, 1}` 은 바이토닉 수열이 아니므로, 이를 유의해서 정답을 구해야한다!