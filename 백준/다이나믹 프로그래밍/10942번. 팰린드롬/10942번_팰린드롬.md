# 10942번 : 팰린드롬?
### 팰린드롬 게임을 하기 위해 자연수 N개와 질문 M개가 주어졌을 때, 조건에 맞는 대답을 구하는 프로그램을 작성하기
#### 조건
- 게임의 룰은 아래와 같음.
  1. 자연수 ```N```개를 칠판에 적는다.(1 ≤ N ≤ 2,000)
  2. 질문을 총 ```M```번 한다.(1 ≤ M ≤ 1,000,000)
  3. 각 질문은 두 정수 ```S```와 ```E```(1 ≤ S ≤ E ≤ N)로 나타낼 수 있으며, ```S```번째 수부터 ```E```번째 까지 수가 팰린드롬을 이루는지를 물어보며, 각 질문에 대해 팰린드롬이다 또는 아니다를 말해야 한다.
- 팰린드롬인 경우에는 ```1```, 아닌 경우에는 ```0```을 출력
### 풀이  
문제를 풀기 앞서 ```팰린드롬```이 무엇일까?  
문제에서 칠판에 ```[1, 12, 1]```이라는 수열이 적혀있다고 가정하자. 이 수열을 거꾸로 나열해도 ```[1, 12, 1]```이기 때문에 이 수열은 ```팰린드롬```이라고 할 수 있다. 이렇듯 ```팰린드롬```이란, 거꾸로 나열해도 기존 값과 동일한 경우를 말한다.  

다시 문제로 돌아가 보자.  
주어진 ```N```과 ```M```의 범위로 보아 ```완전 탐색```으로는 시간 초과가 날 것을 짐작할 수 있다.  
그래서 시간 복잡도를 간단히 하기 위해서 ```다이나믹 프로그래밍```을 이용해보자.  
```점화식```이 쉽게 떠오르지 않기 때문에, 먼저 2차원 DP 테이블을 선언하고 이를 그림으로 표현해보자.  
(문제에서 주어진 예시 사용)
```
   1  2  1  3  1  2  1
1  
2
1
3
1
2
1
```
이 DP 테이블을 채우기만 하면 ```O(M)```의 시간 복잡도로 문제를 해결할 수 있다.  

이 테이블에서 가로 행 ```i```과 세로 열 ```j```이 같을 때는 항상 팰린드롬이라는 알 수 있다.  
예를 들어 ```i = 3```, ```j = 3```은 수열 ```[1]```을 의미하기 때문에 팰린드롬이다.  
DP 테이블을 채워 넣어보자.  
```
   1  2  1  3  1  2  1
1  1
2     1
1        1
3           1
1              1
2                 1
1                    1
```
질문에는 ```S```와 ```E```가 주어진다.  
이는 ```S```번째부터 ```E```번째의 수가 팰린드롬인지 확인하는 것이므로 ```S <= E```가 성립한다고 할 수 있다. 그래서 DP 테이블을 채울 때도 위의 테이블에서 채운 **대각선을 기준으로 윗 부분**만 채워주면 문제를 해결할 수 있다!  

이번에는 비교하는 수가 2개일 때를 보자. 예를 들어 수열 ```[1, 2]```가 있다고 하면 이는 팰린드롬이 아니다.  
즉, 비교하는 수가 2개일 때는 두 수가 서로 같은지만 판별해주면 된다.  
이를 토대로 위에 있는 테이블을 채워보자.  
```
   1  2  1  3  1  2  1
1  1  0
2     1  0
1        1  0
3           1  0
1              1  0
2                 1  0
1                    1
```
비교하는 수가 3개일 때는 어떨까?  
이때는 처음과 마지막 수가 같은지만 비교해주면 된다.  
```[1, 100, 1]```이라는 수열이 있으면 이는 팰린드롬이다.  
이 규칙에 따라 테이블을 채워보면 아래와 같다.  
```
   1  2  1  3  1  2  1
1  1  0  1
2     1  0  0
1        1  0  1
3           1  0  0
1              1  0  1
2                 1  0
1                    1
```
이렇게 비교하는 수의 개수에 따라 테이블을 채워 나가면 되는데, 만약 비교하는 수의 개수가 4, 5, ...?일 때는 어떤 규칙을 가질까?  
이때부터는 현 위치```(i, j)```를 기준으로 왼쪽 아래```(i + 1, j - 1)```의 값을 확인해주면 된다.   
한 가지 예를 살펴보자.  
위 테이블을 기준으로 ```2행``` ```6열```을 채운다고 해보자. ```i = 2```, ```j = 6```일 때는 수열 ```[2, 1, 3, 1, 2]```가 팰린드롬인지 확인해주면 되는데, 그럼 ```i = 3```, ```j = 5```일 때 값을 한 번 확인해보자.  
이 때는 수열 ```[1, 3, 1]```이 팰린드롬인지 여부를 판단하는데, ```[1, 3, 1]```은 팰린드롬이다. 그렇기 때문에 DP 값은 ```1```일 것이다.  
이로서 우리는 처음과 마지막 수를 제외한 가운데에 있는 수열이 팰린드롬을 이룬다는 사실을 알아냈다. 즉, 처음과 마지막 두 수만 비교해서 같다면 팰린드롬이라는 사실을 알 수 있다.  
이를 점화식으로 표현해보면 아래와 같다.  
```
if array[i] == array[j] and dp[i + 1][j - 1] == 1
dp[i][j] = 1 
```
위의 규칙대로 ```다이나믹 프로그래밍```을 수행해서 DP 테이블 채우면 문제를 간단하게 해결할 수 있다!