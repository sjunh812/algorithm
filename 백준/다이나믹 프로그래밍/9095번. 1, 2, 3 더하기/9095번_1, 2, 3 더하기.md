# 9095번 : 1, 2, 3 더하기
### 정수 n이 주어졌을 때, n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 프로그램 작성하기
#### 조건
- 정수 ```n```은 양수이며, ```11```보다 작음.
- 예를 들어, 정수 ```4```를 ```1```, ```2```, ```3```으로 나타내는 방법은 총 ```7```가지이며 아래와 같음.
  ```[1+1+1+1, 1+1+2, 1+2+1, 2+1+1, 2+2, 1+3, 3+1]```
### 풀이  
이 문제는 전형적인 ```다이나믹 프로그래밍``` 유형의 문제이다. ```타일링``` 문제와 매우 유사한데, 이런 문제들은  
```점화식```을 표현하여 쉽게 해결할 수 있지만, 만약  ```점화식```을 떠올리지 못한다면 미궁으로 빠지기 쉬운 문제이다. 이는 ```다이나믹 프로그래밍``` 유형 문제의 특징이며, 다양한 예제의 연습이 필요하다.  

```점화식```을 작성할 때, 보통의 접근법은 이러하다.  
```
dp[i] = i 이전의 dp값을 이용한 연산
```
이러한 방법으로 이 문제의 ```점화식```을 구하면 아래와 같다.
```
dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]
```
어떤 이유로 위와 같은 ```점화식```이 성립하는걸까?  
먼저 ```dp[i] = dp[i - 1]```로 식을 나타낼 수 있다. 처음부터 ```i - 1```까지 모든 경우의 수에 ```1```을 추가한 것이 ```i``` 번째의 경우의 수라 할 수 있기 때문이다. 이와 같은 맥락으로 ```dp[i] = dp[i - 2](2를 추가)```, ```dp[i] = dp[i - 3](3을 추가)```이 성립한다.  
그렇다면 왜 ```dp[i] = dp[i - 4](4를 추가)```와 같은 점화식 뒤에 경우는 판단하지 않을까?  
**이는 앞에서 이미 계산된 중복 연산이기 때문이다.**  

결과적으로 이 ```점화식```을 이용하면 문제를 간단히 해결할 수 있다!