# 2098번 : 외판원 순회
### N과 비용 행렬이 주어졌을 때, 가장 적은 비용을 들이는 외판원의 순회 여행 경로를 구하는 프로그램을 작성하기
### 조건
- 어느 한 도시에서 출발해 `N`개의 도시를 모두 거쳐 다시 원래의 도시로 돌아오는 순회 여행 경로를 계획하려고 함.
- 한 번 갔던 도시로는 다시 갈 수 없음. (단, 맨 마지막에 여행을 출발했던 도시로 돌아오는 것은 예외)
- 2 ≤ `N` ≤ 16
- 비용 행렬의 성분은 1,000,000 이하의 양의 정수이며, 갈 수 없는 경우는 0으로 주어짐.
- `W[i][j]`는 도시 i에서 j로 가기 위한 비용을 나타냄.
- 항상 순회할 수 있는 경우만 입력으로 주어짐.
### 풀이
이 문제는 `완전 탐색`을 이용할 경우 시간초과 판정을 받게 된다.  
왜냐하면 모든 도시를 탐색하는데 드는 비용은 순열의 비용과 동일하기 때문에 `(N - 1)!`의 시간복잡도를 가지게된다. (시작점 제외 `N` - 1)  
따라서 `다이나믹 프로그래밍`을 이용하여 중복되는 경로의 연산은 생략해줘야 시간을 줄일 수 있다.  

한가지 예를 들어보자.  
`N`이 6이라고 할 때, `0→1→2→3→...→0`과 `0→2→1→3→...→0`의 상황이 있다고 하면,  
이 두 경우 모두 4번, 5번 도시를 들려 0번 도시로 돌아와야 한다.  
만약 `0→1→2→3→4→5→0`가 최소 비용 경로라는 사실을 알고 있다면, `0→2→1→3`의 상황에는 뒤에 도시를 탐색하지 않아도   
`0→2→1→3→4→5→0`가 최소 비용 경로라는 것을 알 수 있다!  

따라서 이를 `다이나믹 프로그래밍`에 적용시키기 위해서는 **탐색한 도시들의 번호**와 **탐색한 마지막 도시 번호**를 알고 있어야하므로,  
2차원 `dp` 배열을 선언하여 구현하면 된다. 탐색한 도시들의 번호는 **이진수**를 활용하여 표현할 수 있다.  
예를 들어 `N`이 6일 때, 1번 도시와 2번 도시를 탐색한 경우 **000011**로 표현할 수 있다.  
(**Java**에서는 `<<` 연산자를 이용하여 이진수를 표현할 수 있다.)    

한 가지 유의해야할 점이 있다.  
문제에서 모든 도시를 탐색하고, 다시 시작 도시로 돌아와야 한다고 주어져 있다.  
이때 만약 시작 도시로 돌아오지 못한 경우에 리턴해야하는 최댓값이 `dp` 배열의 초깃값보다 크거나 같은 경우,  
`dp` 배열을 방문하지 않아 초기화되지 않는 상황으로 판단하여 불필요한 연산을 소모해 시간초과를 받는 반례가 있으므로 주의해야한다.

