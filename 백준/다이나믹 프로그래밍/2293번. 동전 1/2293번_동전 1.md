# 2293번 : 동전 1
### 서로 다른 n가지 동전이 주어질 때, 이 동전을 적당히 사용해서 그 가치의 합이 k 되도록 하는 경우의 수를 구하는 프로그램 작성하기
#### 조건
- ```n```가지 종류의 동전과 동전의 가치의 합 ```k```가 주어짐.(1 <= n <= 100, 1 <= k <= 10000)
- 동전의 가치는 ```100000```보다 작거나 같은 자연수
- 사용한 동전의 구성이 같은데, 순서만 다른 것은 같은 경우임.
### 풀이  
이 문제는 ```다이나믹 프로그래밍```을 이용하면 간단하게 해결할 수 있는 문제이다.  
```다이나믹 프로그래밍```을 구현하기 위해서는 먼저 ```점화식```을 작성해야 한다.  
여러번 ```다이나믹 프로그래밍``` 유형을 접해봤다면 아래의 ```점화식``` 형태가 대충 머리 속으로 그려질 것이다.  
```
j : 동전 가치의 번호
dp[i] = dp[i - array[j]]
```
이런 형태와 엇비슷하게 모든 동전의 가치에 대하여 어떻게 잘 수행하면 문제를 해결할 수 있을 것 같은 느낌이 든다.  
하지만 이 문제에는 작은 함정이 존재한다.  
```사용한 동전의 구성이 같은데, 순서만 다른 것은 같은 경우이다.``` 라는 조건이 문제에 있다.  
위에서 대충 구상한 ```점화식```을 이용하면, 특정 DP 값에 대하여 모든 동전의 가치에 대한 계산을 하기 때문에 **중복**되는 동전의 가치가 생기게 된다.  
어떻게 하면 중복된 동전 가치의 사용을 피하면서 ```점화식```을 작성할 수 있을까?   
우리가 ```1```부터 ```k```번째의 DP 값을 채워넣을 때, 한번에 모든 동전의 가치에 대하여 계산하기 때문에 발생하는 문제이므로, 동전의 가치를 순회하여 해당 동전의 가치에 대해서만 ```1```부터 ```k```번째의 DP 값을 채워넣는 것을 반복한다면 동전의 가치가 중복되어 DP 값으로 채워지는 문제를 피할 수 있다!  

위의 해법을 이용한 ```점화식```은 아래와 같다.
```
dp[j] += dp[j - array[i]] 
(단, 0 <= i <= n, array[i] <= j <= k 이며 dp[0] = 1 이다.)
```
추가로 DP 값을 초기화할 때, ```dp[0]```을 ```1```로 초기화 해줘야 한다.  
```j```번째 DP 값을 계산할 때, 만약 ```i```번째의 동전의 가치와 ```j```가 일치하는 경우 ```dp[j] += dp[0]```라는 점화식이 성립한다. 이때 DP 값을 ```1```만큼 늘려줘야 하기 때문에 위와 같이 초기화해준다는 사실을 꼭 기억하자. 