# 9251번 : LCS
### LCS(Longest Common Subsequence, 최장 공통 부분 수열)문제는 두 수열이 주어졌을 때, 모두의 부분 수열이 되는 수열 중 가장 긴 것을 찾는 문제이다. 이때 2개의 문자열이 주어졌을 때, 두 문자열의 LCS의 길이를 출력하는 프로그램 작성하기
#### 조건
- 문자열은 알파벳 대문자로만 이루어져 있으며, 최대 ```1000```글자로 이루어져있다.
### 풀이  
이 문제는 ```LIS(최장 증가하는 부분 수열)```문제와 동일하게 ```다이나믹 프로그래밍```을 이용해 해결할 수 있는 ```다이나믹 프로그래밍``` 대표 유형 문제이다.  

문제에서 두 개의 문자열이 주어졌기 때문에 우리는 어렴풋이 2차원 ```DP``` 테이블을 이용해야함을 알 수 있다.  
```다이나믹 프로그래밍```의 해법상 ```점화식```을 알아내야 하는데 막상 생각으로만으론 찾아내기가 어렵다.  
그럼 2차원 배열 형태의 ```DP``` 테이블을 그려보자.
```
두 문자열 : ACAYKP, CAPCAK

   A  C  A  Y  K  P
C
A
P
C
A
K
```
이제 이 그림을 이용하여 각 문자열이 비교되는 위치에서의 ```LCS``` 최댓값을 작성해보자.
```
   A  C  A  Y  K  P
C  0  1  1  1  1  1
A
P
C
A
K
```
먼저 1행을 완성해보았다.  
문자열 ```AC```와 ```C```를 비교할 때, 처음으로 **공통 부분 수열**이 생긴다. 이때 ```LCS``` 최댓값이 늘어나야 하는데, 아직까지 규칙에 대한 정보가 부족하기 때문에 그림을 좀 더 채워보자.  
**(+참고) 문자 ```C``` 를 비교하는 문자열 ```AC```와 ```C```를 비교할 때, 공통 부분 수열을 찾았기 때문에 이후에 채울 ```LCS``` 최댓값이 해당 값으로 갱신됨을 알 수 있다.(공통 부분 수열을 또다시 찾기 전까지)**
```
   A  C  A  Y  K  P
C  0  1  1  1  1  1
A  1  1  2  
P
C
A
K
```
위 그림은 2행을 채우는 과정이다.  
비교하는 문자 ```A```가 같은 문자열 ```ACA```와 ```CA```를 비교할 때 ```LCS``` 값의 증가가 일어난다.  
이때 ```AC```와 ```C```를 비교할 때의 ```LCS``` 최댓값에서 ```1``` 증가한 값이 ```ACA```와 ```CA```를 비교할 때 ```LCS```의 최댓값이라고 할 수 있다. 왜냐하면 ```AC```, ```C```의 비교에서 각 문자열에 동일한 문자 ```A```가  동시에 추가되었기 때문에 고스란히 ```1```만큼 증가하기 때문이다.  
**(+참고) 위의 말을 수학적으로 접근해보면, ```i```행 ```j```열에서 비교 문자가 같다면, ```i - 1```행 ```j - 1```열의 값에 ```1```을 더한 값이 ```LCS``` 최댓값이 된다.**

반대로 비교하는 문자가 다를 때는 어떨까?  
문자열 ```ACAY```와 ```CA```를 비교할 때를 살펴보자.  
현재 비교하는 문자는 각각 ```Y```와 ```A```이다. 그렇기 때문에 위에서 찾은 규칙을 적용할 수 없다. 그렇다면 ```ACA```와 ```CA``` 그리고 ```ACAY```와 ```C```를 비교할 때를 고려해보자. 아마 이 두 가지 비교에서의 ```LCS``` 최댓값과 우리가 비교할 문자열 간에 ```LCS``` 최댓값과의 차이가 없을 것으로 예상이 된다.  
그러므로 이 두 경우의 ```LCS``` 최댓값 중 더 큰 값을 선택하면 된다.  
즉 ```ACA```와 ```CA```의 ```LCS``` 최댓값 ```2```와 ```ACAY```와 ```C```의 ```LCS``` 최댓값 ```1```중, 더 큰 ```2```가 비교할 ```ACAY```와 ```CA```의 ```LCS``` 최댓값이 된다.  
**(+참고) 현재 비교 중인 위치가 ```i```행 ```j```열이라고 하면, 위에서 말한 두 가지 비교는 각각 ```i - 1```행 ```j```열과 ```i```행 ```j - 1```열을 의미한다.**

이제 위에서 정한 규칙을 토대로 ```점화식```을 작성해보면 이렇다.  
```
비교하는 두 문자가 같은 경우,
dp[i][j] = dp[i - 1][j - 1] + 1

비교하는 두 문자가 다른 경우,
dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
```
이 ```점화식```을 이용해 ```다이나믹 프로그래밍```을 수행하면 문제를 해결할 수 있다!