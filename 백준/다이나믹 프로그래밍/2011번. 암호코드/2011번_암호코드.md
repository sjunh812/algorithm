# 2011번 : 암호코드
### 어떤 암호가 주어졌을 때, 그 암호의 해석이 몇 가지가 나올 수 있는지 구하는 프로그램 작성하기
#### 조건
- 암호화 규칙은 아래와 같음.
  - ```A```는 ```1``` ```B```는 ```2```, 그리고 ```Z```는 ```26```(알파벳 순서대로)
  - 예를 들어 ```BEAN```을 암호화하면 ```251114```가 나옴.
- 암호한 ```251114```를 다시 영어로 바꾸면, 총 ```6```가지 경우가 나올 수 있음.  
  (```BEAAD```, ```YAAD```, ```YAN```, ```YKD```, ```BEKD```, ```BEAN```)
- 암호는 ```5000```자리 이하 숫자로 주어짐.
- 정답이 매우 클 수 있으므로, ```1000000```으로 나눈 나머지를 출력
- 암호가 잘못되어 암호를 해석할 수 없는 경우에는 ```0```을 출력
### 풀이  
이 문제는 ```다이나믹 프로그래밍``` 유형의 문제이다.  

문제 조건 중, 입력으로 주어지는 암호의 자릿수가 최대 ```5000```자리라는 조건에서 순간 당황할 수 있다.  
많은 ```다이나믹 프로그래밍``` 문제에서 DP 테이블을 채울때, ```DP[1]```부터 ```DP[입력 받은 수]```를 구하는 식으로 해결했기 때문이다.  
이 문제에서는 조금 다르게 DP 테이블의 개수를 입력으로 주어진 암호의 자릿수로 정하면 된다.  
예를 들면 ```DP[2]```은 주어진 암호의 2자리(앞에서부터)에 대한 경우의 수이다.

```점화식```을 살펴보자.
```
1. 0을 제외한 모든 1자리 숫자
dp[i] += dp[i - 1]
ex) 25114의 경우의 수 += 2511의 경우의 수 
→ 2511에 마지막 1자리(4)만 추가됐기 때문 

2. 2자리 숫자 (단 0으로 시작하거나, 26보다 큰 숫자는 제외)
dp[i] += dp[i - 2]
ex) 25114의 경우의 수 += 251의 경우의 수 
→ 251에 마지막 2자리(알파벳으로 변환 가능한 14)만 추가됐기 때문 
```
```점화식```은 생각보다 어렵지 않게 생각해낼 수 있다.  
다만, 조금 복잡하다고 느낄 수 있는 점은 위에서 언급했던 **DP 테이블 선언 기준** 및 큰 범위, 그리고 ```점화식```내 예외 처리 케이스의 존재 때문이라고 할 수 있다.  
```점화식```내 예외 처리는 위에서 나와있는대로, ```0```(1자리 숫자)또는 ```0```으로 시작하거나 ```26```보다 커 알파벳으로 변환할 수 없는 2자리 숫자를 예외 처리하면 된다.  
(2자리 숫자를 고려할 때, ```26```보다 큰 경우를 예외 처리하는 이유는 ```26```이상의 수부터는 1자리로 쪼개서 판별해줘야 하기 때문에 **1자리 숫자를 고려하는 ```점화식```에서 이미 중복된 내용**이기 때문이다!)