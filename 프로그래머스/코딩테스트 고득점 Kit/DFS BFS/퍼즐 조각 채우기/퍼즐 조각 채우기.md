# 퍼즐 조각 채우기
### 규칙에 맞게 최대한 많은 퍼즐 조각을 채워 넣을 경우, 총 몇 칸을 채울 수 있는지 return 하도록 solution 함수를 완성하기
### 조건
- 3 ≤ `game_board` 의 행 길이 ≤ 50
- `game_board` 의 각 열 길이 = `game_board` 의 행 길이
    - 즉, 게임 보드는 정사각 격자 모양
    - `game_board` 의 모든 원소는 0 또는 1
    - 0은 빈칸, 1은 이미 채워진 칸을 나타냄
    - 퍼즐 조각이 놓일 빈칸은 1 x 1 크기 정사각형이 최소 1개에서 최대 6개까지 연결된 형태로만 주어짐
- `table` 의 행 길이 = `game_board` 의 행 길이
-` table` 의 각 열 길이 = `table` 의 행 길이
    - 즉, 테이블은 `game_board` 와 같은 크기의 정사각 격자 모양
    - `table` 의 모든 원소는 0 또는 1
    - 0은 빈칸, 1은 조각이 놓인 칸을 나타냄
    - 퍼즐 조각은 1 x 1 크기 정사각형이 최소 1개에서 최대 6개까지 연결된 형태로만 주어짐
- `game_board` 에는 반드시 하나 이상의 빈칸이 있음
- `table` 에는 반드시 하나 이상의 블록이 놓여 있음
### 풀이
이 문제는 `BFS(너비 우선 탐색)` 을 이용하여 해결할 수 있다.  
하지만 문제에서 주어진 조건들이 많고, 까다롭기 때문에 `구현` 에 신경써야 한다.  

풀이과정은 아래와 같다.  
```
1. game_board 와 table 배열에 대하여 각각 BFS 를 수행하여 블록이 들어갈 수 있는 빈칸과 집어 넣을 블록의 좌표값을 저장할 2개의 리스트를 만든다.
2. 빈칸 좌표에 대한 리스트와 블록 좌표에 대한 리스트 내 좌표값을 각각 비교하여 같을 때의 블록의 개수를 더해 답을 얻는다.
(단, 빈칸의 개수와 블록의 개수가 같을 때만 비교를 진행하며, 한번이라도 채운 블록은 다음 탐색에서 제외해야 한다.)
```
풀이과정은 비교적 단순하다.  
다만, 빈칸 좌표의 리스트와 블록 좌표에 대한 리스트를 비교할 때, **회전** 이 가능함을 알아야 한다.  
즉 `0도`, `90도`, `180도`, `270도` 회전했을 때의 좌표값에 대해 각각 비교해야 하며, **기준값(시작점)** 이 `(0,0)` 이 되도록 조정해야 한다.  
(`90도` 회전 : `(x,y)` → `(y,-x)`)  

또한, x 좌표와 y 좌표에 대하여 각각의 좌표 리스트를 사전에 정렬하는 것도 잊지 말고 꼭! 해줘야 한다.  
