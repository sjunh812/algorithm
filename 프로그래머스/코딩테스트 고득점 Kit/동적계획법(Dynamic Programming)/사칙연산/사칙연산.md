# 사칙연산 
### 문자열 형태의 숫자와, 더하기 기호("+"), 뺄셈 기호("-")가 들어있는 배열 arr가 매개변수로 주어질 때, 서로 다른 연산순서의 계산 결과 중 최댓값을 return 하도록 solution 함수를 완성하기
### 조건
- `arr`는 두 연산자 `+`, `-` 와 숫자가 들어있는 배열이며, 길이는 3 이상 201 이하
    - `arr`의 길이는 항상 홀수
    - `arr`에 들어있는 숫자의 개수는 2개 이상 101개 이하이며, 연산자의 개수는 [숫자의 개수 - 1]
- 숫자는 1 이상 1,000 이하의 자연수가 문자열 형태로 주어짐. (ex : "456")
- 배열의 첫 번째 원소와 마지막 원소는 반드시 숫자이며, 숫자와 연산자가 항상 번갈아가며 들어있음.
### 풀이
이 문제는 `다이나믹 프로그래밍`을 이용하여 해결할 수 있는데, 점화식을 세우기 다소 까다로운 문제이다.  

A와 B라는 식이 있다고 해보자.  
```
A + B 가 최댓값을 가지려면, A는 최댓값, B는 최댓값을 가져야 한다.
A - B 가 최댓값을 가지려면, A는 최댓값, B는 최솟값을 가져야 한다.
```

이번에는 A, B, C라는 식에 대하여 살펴보자.
```
A - (B + C) 가 최댓값을 가지려면 A는 최댓값, B + C가 최솟값을 가지기 위해 B와 C도 각각 최솟값을 가져야 한다.
A - (B - C) 가 최댓값을 가지리면 A는 최댓값, B - C가 최솟값을 가지기 위해 B는 최솟값 C는 최댓값을 가져야 한다.
```

이러한 규칙을 적용한 점화식을 세워 재귀적으로 문제를 해결할 수 있다.  
추가로 dp 배열은 아래와 같은 3차원 배열로 정의할 수 있다.  
```
dp[계산할 시작 지점][계산할 끝 지점][최댓값, 최솟값 여부]

ex) dp[0][2][0] = 0번째부터 2번째까지 계산한 최댓값
    dp[2][5][1] = 2번째부터 5번째까지 계산한 최솟값
```