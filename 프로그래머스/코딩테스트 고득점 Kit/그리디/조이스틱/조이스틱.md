# 조이스틱
### 만들고자 하는 이름 name이 매개변수로 주어질 때, 이름에 대해 조이스틱 조작 횟수의 최솟값을 return 하도록 solution 함수 작성하기
### 조건
- `name`은 처음에 A로만 이루어져 있음.  
  ex) 완성해야 하는 이름이 세 글자면 AAA, 네 글자면 AAAA
- 조이스틱을 각 방향으로 움직이면 아래와 같음.
    - ▲ - 다음 알파벳
    - ▼ - 이전 알파벳 (A에서 아래쪽으로 이동하면 Z로)
    - ◀ - 커서를 왼쪽으로 이동 (첫 번째 위치에서 왼쪽으로 이동하면 마지막 문자에 커서)
    - ▶ - 커서를 오른쪽으로 이동 (마지막 위치에서 오른쪽으로 이동하면 첫 번째 문자에 커서)
- 예를 들어 아래의 방법으로 `"JAZ"`를 만들 수 있음.
    - 첫 번째 위치에서 조이스틱을 위로 9번 조작하여 J를 완성
    - 조이스틱을 왼쪽으로 1번 조작하여 커서를 마지막 문자 위치로 이동
    - 마지막 위치에서 조이스틱을 아래로 1번 조작하여 Z를 완성
    - 따라서 11번 이동시켜 "JAZ"를 만들 수 있고, 이때가 최소 이동
- `name`은 알파벳 대문자로만 이루어져 있음.
- `name`의 길이는 1 이상 20 이하
### 풀이
이 문제는 `그리디` 알고리즘을 이용해 풀 수 있다.  
문제를 해결하기 위해 **1) 상하로 움직이는 부분**과 **2) 좌우로 움직이는 부분**으로 나눠 구현해야 한다.  
상하로 움직이는 부분의 경우 `name`을 알파벳별로 차례로 탐색하면서 조작 횟수가 더 작은 방법을 선택하면 된다.  
예를 들어 `Z`를 만들기 위해 A부터 Z까지 위로 **25번** 움직이는 방법과 아래로 **1번** 움직이는 경우가 존재한다.  
이때는 아래로 1번 움직이는 방법을 선택하면 된다. 

좌우로 움직이는 부분의 구현이 까다로운데, 한 가지 예를 들어보자.  
`name`이 **BBBAAAAAAB**로 주어졌을 때, 순서대로 알파벳을 탐색한다고 가정하자.(0번 ~ 9번)  
오른쪽 커서만 사용하면 최대 9번의 조작으로 커서를 이동할 수 있다.  
하지만 경우에 따라 왼쪽으로 이동하는 경우를 섞어주면 더 작은 조작횟수를 구할 수 있는데,  
그 이유는 name에 `A`가 존재할 수 있기 때문이다.  

위 예제에서는 `A`가 연속해서 6개 나왔다.  
따라서, 0부터 2까지 2번 오른쪽으로 커서를 이동했다가 왼쪽으로 2번 커서를 이동하여 다시 처음으로 돌아온다.  
그 후에 왼쪽으로 커서를 연속하는 `A`가 나타나기 직전까지 1번 이동시켜 총 **5번**만에 커서를 이동할 수 있다.  
반대로 연속하는 `A`가 나타나기 직전까지 1번 왼쪽으로 이동했다가 다시 1번 오른쪽으로 이동하여 처음으로 돌아온 뒤에,  
0부터 2까지 2번 오른쪽으로 커서를 이동시켜 총 **4번**만에 커서를 이동할 수 있다.  
위 두 가지 케이스 중에 더 작은 조작횟수를 선택하면 된다.  

좌우로 움직이는 부분을 간단히 코드로 작성하면 아래와 같이 구현할 수 있다.  
```Java
// 연속하는 A의 마지막 인덱스의 다음 인덱스
aIndex = i + 1;    
while (aIndex < name.length() && name.charAt(aIndex) == 'A') {
    aIndex++;
}

// 좌우 조작횟수가 더 작은 방법 선택
move = Math.min(move, i * 2 + name.length() - aIndex);
move = Math.min(move, (name.length() - aIndex) * 2 + i);
```
