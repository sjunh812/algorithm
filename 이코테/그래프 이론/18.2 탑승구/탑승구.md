# 탑승구
### 비행기를 최대 몇 대까지 탑승구에 도킹할 수 있는지를 출력하는 프로그램 작성하기
#### 조건
- 탑승구의 수 ```G```, 비행기의 수 ```P```가 주어짐.(1 <= G, P <= 100000)
- 공항에는 ```P```개의 비행기가 차례대로 도착할 예정이며, ```i```번째 비행기를 ```1```번부터 ```g```번째(1 <= g <= G) 탑승구 중 하나에 영구적으로 도킹함.
- 다른 비행기가 도킹하지 않은 탑승구에만 도킹할 수 있으며, 어떠한 탑승구에도 도킹할 수 없는 비행기가 나올 경우, 그 시점에서 공항의 운행을 중지함.
### 풀이
이 문제는 ```서로소 집합``` 알고리즘을 이용하면 효율적으로 해결할 수 있다.  
각 탑승구를 서로 다른 집합으로 나타낸다고 해보자. 만약 전체 탑승구가 ```4개(G = 4)```일 때, 다음과 같이 그릴 수 있다. 초기 상태는 모두 루트 노드로 자기 자신을 가리키고 있다고 가정한다. 또 ```0번째``` 탑승구는 존재하지 않지만, 문제 해결을 위해 ```0번``` 탑승구도 그려주도록 하자.  
```
(노드)  0  1  2  3  4
(루트)  0  1  2  3  4 
```
이때 비행기가 순서대로 들어오면 차례대로 도킹을 수행해야 하는데, **가능한 큰 번호의 탑승구로 도킹을 수행**한다고 가정해보자.  
이때 우리는 도킹하는 과정을 탑승구 간 ```union(합집합)``` 연산으로 이해할 수 있다. 새롭게 비행기가 도킹이 되면, **해당 집합을 바로 왼쪽에 있는 집합과 합친다**. 단, 집합의 루트가 ```0```이면, 더 이상 도킹이 불가능하는 것으로 판단한다.  
이러한 과정을 통해 문제를 해결할 수 있다.  

아래와 같은 입력 예시가 주어졌을 때를 살펴보자.   
```
2, 2, 3, 3, 4, 4, 1, 2, 3
```
첫 번째 비행기는 1부터 2까지의 탑승구 중 하나에 도킹할 수 있다.  
따라서 2번 노드를 확인하는데, 현재 2번 노드의 루트는 ```2```이다. 그러므로, 2번 노드와 1번 노드에 대하여 합칩합 연산을 수행한다,
```
1. 첫 번째 비행기 : 1 <= g <= 2
(노드)  0  1  2  3  4
(루트)  0  1  1  3  4 
```

두 번째 비행기는 1부터 2까지의 탑승구 중 하나에 도킹할 수 있다.  
따라서 2번 노드를 확인하는데, 현재 2번 노드의 루트는 ```1```이다. 그러므로, 1번 노드와 0번 노드에 대하여 합칩합 연산을 수행한다,
```
2. 두 번째 비행기 : 1 <= g <= 2
(노드)  0  1  2  3  4
(루트)  0  0  0  3  4 
```

세 번째 비행기는 1부터 3까지의 탑승구 중 하나에 도킹할 수 있다.  
따라서 3번 노드를 확인하는데, 현재 3번 노드의 루트는 ```3```이다. 그러므로, 3번 노드와 2번 노드에 대하여 합칩합 연산을 수행한다,
```
3. 세 번째 비행기 : 1 <= g <= 3
(노드)  0  1  2  3  4
(루트)  0  0  0  0  4 
```

네 번째 비행기는 1부터 3까지의 탑승구 중 하나에 도킹할 수 있다.  
따라서 3번 노드를 확인하는데, 현재 3번 노드의 루트는 ```0```이다. 루트가 ```0```이라는 점에서 더 이상 도킹할 수 없다는 의미이므로, 여기에서 마친다. 지금까지 총 3개의 비행기가 도킹이 되었으므로, ```3```을 출력하면 정답이다.  

따라서 이 문제는 ```서로소 집합``` 자료구조를 이용하여 해결할 수 있다!