# 숨바꼭질
### 숨바꼭질을 하면서 술래로부터 잡히지 않도록 숨을 헛간을 찾고 있다. 이때 1번 헛간으로부터 최단 거리가 가장 먼 헛간이 가장 안전하다고 할 때, 숨을 헛간의 번호를 출력하는 프로그램 작성하기
#### 조건
- 헛간은 ```1번``` 부터 ```N번```까지 있음.(2 <= N <= 20000)
- 총 ```M```개의 양방향 통로가 존재하며, 하나의 통로는 서로 다른 두 헛간을 연결함.(1 <= M <= 50000)
- 전체 맵은 항상 어떤 헛간에서 다른 어떤 헛간으로 도달이 가능한 형태로 주어짐.
- 숨어야하는 헛간의 번호, 그 헛간까지의 거리, 그리고 그 헛간과 같은 거리를 갖는 헛간의 개수을 출력  
  (단, 거리가 같은 헛간이 여러 개면 가장 작은 헛간의 번호를 출력한다.)
### 풀이
이 문제는 ```다익스트라``` 알고리즘을 이용하여 ```1번``` 노드(헛간)로 부터 다른 모든 노드로의 **최단 거리**를 계산한 뒤에, 가장 최단 거리가 긴 노드를 찾는 문제이다.  

예를 들어 문제에서의 예제 입력을 살펴보자.  
항상 출발 노드는 ```1번``` 노드라고 문제에서 명시하였으므로, ```다익스트라``` 알고리즘을 이용하여 ```1번``` 노드에서 출발했을 때의 모든 최단 거리를 계산하면 다음과 같은 최단 거리 테이블을 구할 수 있다.
```
헛간1  헛간2  헛간3  헛간4  헛간5  헛간6
0      1     1      2      2     2
```
위의 테이블을 보면, 이 예시에서 최단 거리가 가장 긴 노드까지의 최단 거리는 ```2```라는 것을 알 수 있으며, 최단 거리가 ```2```인 노드가 ```3개```인 것을 확인할 수 있다.  
문제에서는 최단 거리가 같은 헛간이 여러 개이면 가장 작은 헛간 번호를 출력하라고 하였으므로, 이 경우 ```4번``` 노드를 출력하면 된다.  
즉, 최단 거리 테이블을 구한 이후에는 손쉽게 문제에서 요구하는 답을 도출할 수 있다.  

문제에서의 거리(비용)가 모두 ```1```이기 때문에 ```BFS(너비 우선 탐색)```를 이용하여 최단 거리를 계산할 수도 있다는 점도 알아두자.