# 카드 정렬하기
### N개의 숫자 카드 묶음의 각각의 크기가 주어질 때, 최소한 몇 번의 비교가 필요한지를 구하는 프로그램 작성하기
#### 조건
- 각 묶음의 카드의 수를 ```A```, ```B```라 하면 보통 두 묶음을 합쳐서 하나로 만드는데 ```A + B``` 번의 비교를 해야함.
- 숫자 카드의 묶음의 각각의 크기 ```N```은 1 이상 100000 이하 자연수
### 풀이  
이 문제의 핵심 아이디어는 ```항상 가장 작은 크기의 두 카드 묶음을 합쳤을 때 최적의 해를 보장```한다는 점이다.  
따라서 매 상황에서 무조건 가장 작은 크기의 두 카드 묶음을 합치면 된다는 점에서, 이 문제는 ```그리디 알고리즘```으로도 분류할 수 있다. 다만, 정렬 개념을 활용하는 아이디어가 필요해 ```정렬``` 유형의 문제로도 분류 가능하다.  

한 가지를 예를 통해 살펴보자.  
카드 묶음이 ```40, 30, 30, 50```으로 주어졌을 때의 예시이다.  
```
카드 묶음 정렬(오름차순) : 30, 30, 40, 50

1. 30과 30을 묶는다.(30 + 30 = 60묶음 생성, answer = 60)
2. 40과 50을 묶는다.(40 + 50 = 90묶음 생성, answer = 150)
3. 60과 90을 묶는다.(60 + 90 = 150묶음 생성, answer = 300)
4. 모든 숫자 카드를 150묶음으로 합쳤다!

답 : 300
```
위의 예시를 보면 알 수 있다시피 카드와 카드를 묶으면 하나의 새로운 묶음이 생긴다.  
우리는 이 묶음을 이용해 다음 카드와 바로 묶는 것이 아닌, 남아있는 카드 묶음 중 제일 작은 두 개의 카드 묶음을 골라
합쳐야 한다.  
이러한 과정을 매우 효과적으로 수행할 수 있는 자료구조는 바로 ```우선순위 큐(Priroity Queue)```이다.  
```우선순위 큐```를 이용하면 원소를 넣었다가 빼는 것만으로도 정렬된 결과를 얻을 수 있기 때문이다.
