# 효율적인 화폐 구성
### N가지 종류의 화폐가 있을 때, 이 화폐들의 개수를 최소한으로 이용해서 그 가치의 합이 M원이 되도록하는 프로그램 작성하기
#### 조건
- 화폐의 종류 ```N```과 목표 금액 ```M```원이 주어짐.(1 <= N <= 100, 1 <= M <= 10000)
- 모든 화폐는 ```10000```보다 작거나 같은 자연수
- M원의 합이 불가능할 때는 ```-1```을 출력
### 풀이  
이 문제는 ```그리디 알고리즘``` 유형에서 다루었던 ```거스름돈``` 문제와 거의 동일하다. 단지 화폐의 단위에서 큰 단위가 작은 단위의 배수가 아니라는 점만 다르다. **그렇기 때문에 ```그리디 알고리즘```을 사용했던 예시처럼 매번 가장 큰 화폐 단위부터 처리하는 방법으로는 해결할 수 없고 ```다이나믹 프로그래밍```을 이용해야 한다.**  

이번 문제는 적은 금액부터 큰 금액까지 확인하며 차례대로 만들 수 있는 최소한의 화폐 개수를 찾으면 된다. 금액 ```i```를 만들 수 있는 최소한의 화폐 개수를 ```ai```, 화폐의 단위를 ```k```라고 했을 때 다음과 같이 ```점화식```을 작성할 수 있다.  
```ai-k```는 금액 ```i - k```를 만들 수 있는 최소한의 화폐 개수를 의미한다.  
```
- ai-k를 만드는 방법이 존재하는 경우, ai = min(ai, ai-k + 1)
- ai-k를 만드는 방법이 존재하지 않는 경우, ai = 10001
```
이 ```점화식```을 **모든 화폐 단위**에 대하여 차례대로 적용하면 된다.  
실제로 문제를 풀기 위해서는 가장 먼저 ```K```의 크기만큼 리스트를 할당한다. 이후에 각 인덱스를 ```금액```으로 고려하여 ```메모이제이션```을 진행한다.  
예를 들어 ```N = 3```, ```K = 7```이고, 각 화폐의 단위가 ```2```, ```3```, ```5```인 경우를 생각해보자.  
``` 
step 1) 초기화
각 인덱스에 해당하는 값으로 10001을 설정한다. 즉, 특정 금액을 만들 수 있는 화폐 구성이 가능하지 않다는 의미이다.
단, 0원의 경우, 화폐를 하나도 사용하지 않았을 때(화폐 단위 일 때) 만들 수 있으므로 값으로 0을 설정한다.
초기 리스트는 아래와 같다.

[0, 10001, 10001, 10001, 10001, 10001, 10001, 10001]
```
```
step 2) 화폐 단위 2 확인
앞서 언급한 점화식에 따라 아래와 같은 리스트가 갱신된다.
예를 들어 인덱스 2의 경우 1이라는 값을 가지는데, 이는 2원짜리 화폐 하나를 이용하여 2원을 만들 수 있다는 의미이다. 
인덱스가 4인 경우, a4 = min(10001, a2 + 1) 이므로 2라는 값을 가진다.
인덱스가 3인 경우, a3 = min(10001, a1 + 1) 인데, a1이 10001이므로 a3은 10001의 값을 가진다.

[0, 10001, 1, 10001, 2, 10001, 3, 10001]
```
```
step 3) 화폐 단위 3 확인
앞서 언급한 점화식에 따라서 값을 도출하면 다음과 같이 리스트가 갱신된다.
예를 들어 a5 = a2 + 1로 2라는 값을 가지는데, 이것은 2원짜리 화폐 1개, 3원짜리 화폐 1개로 (2 + 3) = 5원을 만들 수 있다는 의미이다.

[0, 10001, 1, 1, 2, 2, 2, 3]
```
```
step 4) 화폐 단위 5 확인
앞서 언급한 점화식에 따라서 값을 도출하면 다음과 같이 리스트가 갱신된다.
예를 들어 a7 = min(a7, a2 + 1)로 2라는 값을 가진다. 이는 2원짜리 화폐 1개, 5원짜리 화폐 1개로 (2 + 5) = 7원을 만들 수 있다는 의미가 된다. 
이전 단계에서 a7은 3이었다. (2 + 2 + 3) = 7원으로 3개의 화폐를 사용했을 때를 나타낸 것인데, 현재 단계에서 더 적은 화폐의 개수를 사용하므로 현재 단계의 값으로 갱신된다.

[0, 10001, 1, 1, 2, 1, 2, 2]
```
결과적으로 7원을 만들기 위한 최소의 화폐 개수는 2개이다!