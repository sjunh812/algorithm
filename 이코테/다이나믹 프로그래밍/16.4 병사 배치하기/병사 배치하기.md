# 병사 배치하기
### 병사에 대한 정보가 주어졌을 때, 남아있는 병사의 수가 최대가 되도록 하기 위해서 열외해야 하는 병사의 수를 출력하는 프로그램 작성하기
#### 조건
- 병사를 배치할 때는 전투력이 높은 병사가 앞쪽으로 오도록 내림차순으로 배치하고자 함. 즉, 앞쪽에 있는 병사의 전투력이 항상 뒤쪽에 있는 병사보다 높아야 함.
- 병사의 수 ```N```명이 주어짐.(1 <= N <= 2000)
- 각 병사의 전투력은 ```10000000```보다 작거나 같은 자연수
### 풀이  
이 문제의 기본 아이디어는 ```가장 긴 증가하는 부분 수열(LIS, Longest Increasing Subsequence)```로 알려진 전형적인 ```다이나믹 프로그래밍``` 문제의 아이디어와 같다.  
```가장 긴 증가하는 부분 수열```문제란, 하나의 수열이 주어졌을 때 값들이 증가하는 형태의 가장 긴 부분 수열을 찾는 문제이다.  

한가지 예를 살펴보자.  
하나의 수열 ```array = [10, 20, 10, 30, 20, 50]```가 있다고 하자. 이때 가장 긴 증가하는 부분 수열은 ```[10, 20, 30, 50]```이 될 것이다.  
```d[i] = array[i]를 마지막 원소로 가지는 부분 수열의 최대 길이```라고 정의하면, ```가장 긴 증가하는 부분 수열```을 계산하는 ```점화식```은 다음과 같다. 이때 초기의 ```DP``` 테이블의 값은 모두 ```1```로 초기화한다.  
```
모든 0 <= j < i 에 대하여, 
d[i] = max(d[i], d[j] + 1) if array[j] < array[i]
```
그렇다면 이번에는 ```DP``` 테이블 갱신되는 과정을 살펴보자.  
```i```를 1 부터 ```n - 1``` 까지 증가시키며, 점화식에 따라 테이블을 갱신하면 아래와 같다.  
```
[10, 20, 10, 30, 20, 50]
[1, 1, 1, 1, 1, 1] → 초기 상태
[1, 2, 1, 1, 1, 1] → i = 1
[1, 2, 1, 1, 1, 1] → i = 2
[1, 2, 1, 3, 1, 1] → i = 3
[1, 2, 1, 3, 2, 1] → i = 2
[1, 2, 1, 3, 2, 4] → i = 4
```
최종적인 ```DP``` 테이블의 값은 ```[1, 2, 1, 3, 2, 4]```이고, 이렇게 테이블에 남아 있는 값들 중에서 가장 큰 값이 ```가장 긴 증가하는 부분 수열```의 길이이다. 즉, 현재 예시에서는 ```4```가 최장 길이가 된다.  

이제 문제를 확인해보자. 현재의 문제는 병사를 배치할 때 전투력이 높은 병사가 앞쪽에 오도록 내림차순 배치를 하고자 한다. 따라서 이 문제를 ```가장 긴 감소하는 부분 수열```의 길이를 계산하는 문제로 간주하고, 입력으로 주어진 원소의 순서를 뒤집은 뒤에 ```가장 긴 증가하는 부분 수열```문제를 풀 때의 ```점화식```을 그대로 적용하면 해결할 수 있다!