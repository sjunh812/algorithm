# 무지의 먹방 라이브
### 무지가 먹방을 시작한 지 K초 후에 네트워크 장애로 인해 방송이 잠시 중단되었다. 네트워크 정상화 후 다시 방송을 이어갈 때, 몇 번 음식부터 섭취해야할까?
#### 조건
- 각 음식을 모두 먹는 데 필요한 시간이 담겨 있는 배열 ```food_times```, 네트워트 장애가 발생한 시간 ```K```초가 주어짐.
- 무지는 1번 음식부터 먹기 시작혀며, 회전판은 번호가 증가하는 순서대로 음식을 무지 앞으로 가져다 놓는다.
- 회전판이 다음 음식을 무지 앞으로 가져오는 데 걸리는 시간은 없다.
- 무지는 음식 하나를 1초 동안 섭취한 후 남은 음식은 그대로 둔다.
- 다음 음식이란, 아직 남은 음식 중 다음으로 섭취해야 할 가장 가까운 번호의 음식을 말한다.
- 만약 더 섭취해야 할 음식이 없다면 -1을 반환한다.
### 풀이
이 문제는 시간이 적게 걸리는 음식부터 확인하는 **그리디 알고리즘** 접근 방식으로 해결할 수 있다. 

모든 음식을 시간을 기준으로 정렬한 뒤에, 시간이 적게 걸리는 음식부터 제거해 나가는 방식을 이용하면 된다.  
```우선순위 큐```를 이용하여 구현할 수 있는데, 고려해야할 부분이 많아 까다로울 수 있는 문제다.

간단한 예시로 풀이하자면,
```
- K : 15초
- 1번 음식 : 8초 소요
- 2번 음식 : 6초 소요
- 3번 음식 : 4초 소요

1) 최초에 모든 음식을 시간 오름차순 기준으로 우선순위 큐(최소 힙)에 삽입한다.
(단, K초 후에 먹어야 할 음식의 번호를 출력해야 하므로 클래스 형태(시간, 번호)로 만들어 삽입한다.)

2) 첫 단계이서 가장 적게 걸리는 음식 3번을 뺀다.
다만 현재 남아있는 음식이 총 3개 이므로, 3번 음식을 빼기 위해서는  
3(남은 음식 개수) * 4(3번 음식을 먹는 시간) = 12초가 걸리게된다. 결과적으로 전체 남은 시간은 3초이다.

3) 두 번째 단계에서는 2번 음식을 빼야한다.
뺄 시간은 2(남은 음식 개수) * 2(2번 음식을 먹는 시간, 이전 음식을 먹는 시간 차감) = 4초가 된다.
하지만 현재 남은 3초보다 크기 때문에 빼지 않는다.

4) 따라서 `다음으로 먹어야 할`음식의 번호를 찾아 출력하기 위해 매초 먹어야 할 음식들을 번호 순으로
다시 정렬 후 나열한다. 전체 남은 시간 3초이므로, 전체 음식의 개수가 2개이기 때문에 
두 개의 음식 마지막 인덱스의 2번 음식을 출력한다.