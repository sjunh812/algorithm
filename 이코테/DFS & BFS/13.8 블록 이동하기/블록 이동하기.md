# 블록 이동하기
### 빈칸과 벽으로 이루어진 지도가 주어질 때, 로봇이 (N, N) 위치까지 이동하는데 필요한 최소 시간을 return 하도록 solution 함수를 완성하기
#### 조건
- 지도의 크기는 ```N x N```(5 <= N <= 100)
- 로봇의 크기는 ```2 x 1```이며, ```(1, 1)``` 위치에서 ```가로 방향```으로 놓여 있는 상태에서 시작함.
- ```0```은 빈칸, ```1```은 벽을 나타냄.
- 로봇은 ```상, 하, 좌, 우```로 이동 가능하며, ```90도```씩 회전할 수 있음. 이때 각각 1초의 시간이 소요됨.
- 로봇이 회전할 때는 축이 되는 칸으로부터 대각선 방향에 있는 칸에는 벽이 없어야 함.
- 로봇이 항상 목적지에 도착할 수 있는 경우만 입력으로 주어짐.
- 아래는 임의의 입력을 나타낸 그림이다.
### 풀이
이 문제는 다소 복잡해 보이지만, 전형적인 ```BFS``` 문제 유형이다.  
문제에서 로봇이 존재할 수 있는 각 위치(각 칸)을 노드로 보고, 인접한 위치와 비용이 1인 ```간선```으로 연결되어 있다고 볼 수 있다.  
간선의 비용이 모두 1로 동일하기 때문에 ```BFS```를 이용하여 최적의 해를 구할 수 있다. 다시 말해 이 문제는 ```(1, 1)```의 위치에 존재하는 로봇을 ```(N, N)```의 위치로 옮기는 ```최단 거리```를 계산하는 문제로 볼 수 있다.  

다만, 이 문제가 일반적인 ```BFS``` 문제와 다른 점은, 로봇이 차지하고 있는 위치가 **두 칸**이며 회전을 통해 이동할 수 있다는 점이다.  
물론 로봇이 차지하고 있는 위치가 두 칸이라고 해도, 여전히 방문 여부를 관리할 수 있으니 걱정하지 말자.  
위치 정보를 리스트로 처리하면 된다. 예를 들어 시작 할때 ```[[1, 1], [1, 2]]```형태의 리스트가 저장되게 된다. 이렇게 로봇의 상태를 위치 정보의 리스트를 이용하여 관리하면, 한 번 방문한(큐에 들어간) 로봇의 상태는 두 번 방문하지 않도록 하면 된다.  


